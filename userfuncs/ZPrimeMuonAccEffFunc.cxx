/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

// class declaration include file below retrieved from workspace code storage
#include "ZPrimeMuonAccEffFunc.h"
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(ZPrimeMuonAccEffFunc) 

ZPrimeMuonAccEffFunc::ZPrimeMuonAccEffFunc(const char *name, const char *title, 
					   RooAbsReal& zPrimeMass,
					   RooAbsReal& effScale,
					   RooAbsReal& effA,
					   RooAbsReal& effB,
					   RooAbsReal& effC,
					   RooAbsReal& effD,
					   RooAbsReal& trigA,
				           RooAbsReal& trigB,
					   RooAbsReal& trigC):
  RooAbsReal(name,title), 
  zPrimeMass_("zPrimeMass","zPrimeMass",this,zPrimeMass),
  effScale_("eff_scale","eff_scale",this,effScale),
  effA_("eff_a","eff_a",this,effA),
  effB_("eff_b","eff_b",this,effB),
  effC_("eff_c","eff_c",this,effC),
  effD_("eff_d","eff_d",this,effD), 
  trigA_("trig_a","trug_a",this,trigA), 
  trigB_("trig_b","trig_b",this,trigB), 
  trigC_("trig_c","trig_c",this,trigC) 
{ 
} 


ZPrimeMuonAccEffFunc::ZPrimeMuonAccEffFunc(const ZPrimeMuonAccEffFunc& other, const char* name) :  
  RooAbsReal(other,name), 
  zPrimeMass_("zPrimeMass",this,other.zPrimeMass_),
  effScale_("eff_scale",this,other.effScale_),
  effA_("eff_a",this,other.effA_),
  effB_("eff_b",this,other.effB_),
  effC_("eff_c",this,other.effC_),
  effD_("eff_d",this,other.effD_),
  trigA_("trig_a",this,other.trigA_),
  trigB_("trig_b",this,other.trigB_),
  trigC_("trig_c",this,other.trigC_)

  
{ 
} 



double power3(double x){return x*x*x;}
double power2(double x){return x*x;}
Double_t ZPrimeMuonAccEffFunc::evaluate() const 
{ 
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  return effScale_*(effA_+effB_/power3(zPrimeMass_+effC_)+power2(zPrimeMass_)*effD_)*(trigA_ + trigB_*zPrimeMass_ + trigC_*zPrimeMass_*zPrimeMass_); 
} 



